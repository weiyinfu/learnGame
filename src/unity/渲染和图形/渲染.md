# 显示

人脑的信息输入主要靠视觉、听觉。视觉输入的信息占比更大。视觉像面条、像馒头一样，是主食；而听觉像调味剂，可以让视觉更有意思。  
计算机显示出东西来，这个过程涉及到很多层。最底层是显示器，显示器就是一块固定大小的内存，这块内存空间在不停地刷新，就形成了我们看到的屏幕。那么是谁在往这块内存里面不停地送数据呢？是显卡，显卡通过计算得到一堆内存数据交给显示器去展示。显卡依旧是硬件层面。    
是谁告诉显卡应该计算那些东西呢？是图形库，图形库对各个厂家的显卡做了屏蔽，这是第一层软件层。几乎所有的操作系统都需要依赖某种图形库。

# 显卡

GPU，Graphic Processing Unit.  
计算机中用于渲染图像的处理器，分为集成显卡和独立显卡，二者的区别就是独立显卡不会占用CPU性能，目前大部分机器都是独立显卡。  
显卡厂商：

* 英伟达Nvidia
* Intel

# 图形API

* OpenGL：老牌开源图形API
* DirectX：微软出品，Windows平台使用广泛。
* Vulkan：比较新的图形API
* Skia：Google开源图形库，底层基于Vlukan和OpenGL。flutter就是基于Skia图形库实现的。skia是一个2d图形库，用于绘制文本、几何图形、图片等。Jetbrain退出了skia的Java封装：
  https://github.com/JetBrains/skija
* WebGl：web端的图形API，底层一般使用OpenGL等最底层的库。
* OpengIES
* Metal

其中，图形API也分底层和高层，底层的图形API被称为显卡驱动，例如：

* OpenGL
* DirectX
* Vulkan

# GPU流水线顺序

GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序）  
顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex
Shader（定点着色器）完成。  
光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。  
纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture
mapping）工作完成对多变形表面的贴图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping
unit）即是用来完成此项工作。  
像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel
Shader（像素着色器）完成。  
最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。  
总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。

# 什么是渲染管道？

答：是指在显示器上为了显示出图像而经过的一系列必要操作。
渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。  
主要步骤有：  
本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化。

# 渲染管线

RP：render pipeline  
SRP：scriptable render pipeline  
HDRP：高精度渲染管线，high definition  
URP：universal渲染管线。 universal render pipeline。

# GPU和CPU

GPU和CPU各自具有优势和缺点：

|     | 优点        | 缺点        | 指令     |
|-----|-----------|-----------|--------|
| GPU | 只能做一些简单操作 | 一些简单操作    | 单指令多数据 |
| CPU | 运行缓慢      | 可以做一些复杂操作 | 单指令但数据 |  


GPU就像写numpy，CPU就像用Python标准库写循环。  
