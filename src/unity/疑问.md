# Image和RawImage的区别
RawImage核心代码比Image少很多，Raw Image不支持交互，可用于显示任何图片而不仅仅是Sprite，一般用在背景、图标上,支持UV Rect(用来设置只显示图片的某一部分)，而Image不支持UV Rect
# unity3d打印日志
`Debug.Log("This is debug");`
# find an inactive object
Unity的对象树许多关键功能是缺失的，需要开发者自己实现。对于寻找inactive的物体这一简单功能，unity没有提供便捷的函数，使用Resources.FindObjectsTypeAll能够实现。  

```cs
 var fooGroup = Resources.FindObjectsOfTypeAll<AnUniqueClass>();
 if (fooGroup.Length > 0) {
   var foo = fooGroup[0];
 }
```

下面是[网上的一些讨论](https://answers.unity.com/questions/890636/find-an-inactive-game-object.html)：
> Oh my god, I can't believe they didn't support this simple, essential and frequent feature even in 2018...?!?!?!

> That's got to be a real wrong name choice here. I would never expect to look into that class. Resources tells me it deals with resources folder, so how come this find them in the scene??!! Is that another intern job at Unity? Anyway, it does the job indeed.
> don't use this method. it has permanent effect on your assets. find another solution.

```
SpriteRenderer[] onlyActive = GameObject.FindObjectsOfType<SpriteRenderer>();

SpriteRenderer[] activeAndInactive = GameObject.FindObjectsOfType<SpriteRenderer>(true);

// requires "using System.Linq;"
SpriteRenderer[] onlyInactive = GameObject.FindObjectsOfType<SpriteRenderer>(true).Where(sr => !sr.gameObject.activeInHierarchy).ToArray();
```

# 寻找一个对象下的某个对象
实现一个扩展方法：
```
 public static GameObject FindObject(this GameObject parent, string name)
 {
     Transform[] trs= parent.GetComponentsInChildren<Transform>(true);
     foreach(Transform t in trs){
         if(t.name == name){
              return t.gameObject;
         }
     }
     return null;
 }
```

使用时：
```
GameObject obj = parentObject.FindObject("MyObject");
```

# 寻找一个对象下的子组件
```
 Transform childTransform = gameObject.transform.GetComponentsInChildren<Transform>(true).FirstOrDefault(t => t.name == "Name Of Child Object");
```

# 找到所有的游戏对象
```plain
 public static List<GameObject> FindAllObjectsInScene()
     {
         UnityEngine.SceneManagement.Scene activeScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
 
         GameObject[] rootObjects = activeScene.GetRootGameObjects();
 
         GameObject[] allObjects = Resources.FindObjectsOfTypeAll<GameObject>();
 
         List<GameObject> objectsInScene = new List<GameObject>();
 
         for (int i = 0; i < rootObjects.Length; i++)
         {
             objectsInScene.Add(rootObjects[i]);
         }
 
         for (int i = 0; i < allObjects.Length; i++)
         {
             if (allObjects[i].transform.root)
             {
                 for (int i2 = 0; i2 < rootObjects.Length; i2++)
                 {
                     if (allObjects[i].transform.root == rootObjects[i2].transform && allObjects[i] != rootObjects[i2])
                     {
                         objectsInScene.Add(allObjects[i]);
                         break;
                     }
                 }
             }
         }
         return objectsInScene;
     }
```

# UGUI和NGUI的区别
1.UGUI界面展示是在画布下(Canvas)，而NGUI是在UIRoot下

2.UGUI继承RectTransform，RectTransform继承Transform，而Ngui直接继承Transform

3.UGUI没有图集Atlas，是直接使用图片，而Ngui需要使用图集，对图集进行管理和维护

4.UGUI有锚点，可以自动适配屏幕，NGUI没有暂未发现此功能

5.UGUI中Btn需要有sprite，button，而NGUI只需要一个UIButton方法，和一个BoxCollider。

6.NGUI基于C#编写的，会产出比较多的GC，UGUI是基于C++，性能比较好。基于canvas渲染比较好。


# unity创建object的三种方法
```
//1.第一种方法

GameObject go = new GameObject("name");  //name 为名字

//2.第二种方法

public GameObject prefab;

GameObject.Instantiate(prefab);//可以很具prefab 或者另外一个物体克隆

//3.第三种方法

//创建基本图形

GameObject.CreatePrimitive(PrimitiveType.Cube);
```

# unity使用prefab的两种方式
加载prefab有两种方式
* 方法一：设置脚本的public字段 ，然后再界面上传参。这种方式比较死板。
* 方法二：使用Resource.Load()
在代码里用Resource.Load()来加载实例化预设，前提是预设预提必须放在Assets/Resources的目录下。当然你也可以在 Assets/Resources/MyPrefabs。
```
// Use this for initialization
void Start () {
//参数一：是预设 参数二：实例化预设的坐标  参数三：实例化预设的旋转角度
GameObject instance = (GameObject)Instantiate(Resources.Load("Cubeprefab"), transform.position)
```

# 场景管理器
```
using UnityEngine.SceneManagement;

SceneManager.LoadScene("2048");
SceneManager.GetAllScenes();
SceneManager.GetSceneByName();
SceneManager.GetSceneByPath();
SceneManager.MoveGameObjectToScene();
Debug.Log(SceneManager.getscene)
```


# unity的so的易错点
- 如果so中出现segment fault等崩溃性错误，则unity整个都会崩溃。
- unity editor在打开的整个过程中，so只会加载一次。因此如果so发生变化，只能重启unity editor。

# unity使用软链接快速切换平台
我们的项目文件全部存放在Assets文件夹中，其中包含了我们整个项目运行所需的全部资产，如模型、贴图、材质、声音、视频等等，这些资产在导入时会生成对应的.meta文件，这些文件保存了资产之间的引用关系信息。  
在Assets中所有资产在导入过程中，都经历了筛选和创建，会形成与之对应的设置，所有的设置都存放在ProjectSettings文件夹中。  
如果使用Unity2018版本，我们项目中所有引用的包信息都存放在Packages文件夹中。
Library文件夹是Unity根据项目自动生成的，当我们的资源导入到Unity时，这些资源并没有被改变，而是根据我们的设置生成平台可以运行且处理后的文件放置到Library文件夹中，当我们的平台发生变化时，Library中的文件会根据变化重新编译生成与之相应的内容。
obj文件夹存放了Unity的部分缓存信息。  
根据以上部分，当我们需要切换平台时，其改变的内容主要存在于Library文件夹中，我们可以根据不同的平台复制多个工程，在打包时把Assets、Packages和ProjectSettings文件夹放入其他平台的文件夹中进行编译即可。  
把assets和package两个文件夹使用软链接，项目配置主要位于project settings目录。建立两个项目。unity设计的多平台方案切换起来过于耗时。   

# 删除游戏对象
* `Destroy(this.gameObject);`
* `DestroyImmediate(this.gameObject);`

如果在一个Update中，先执行删除操作再执行添加操作，则应该使用DestroyImmediate。  


# 动态加载资源的方式?
1. Resources.Load();
2. AssetBundle：Unity5.1版本后可以选择使用Git: https://github.com/applexiaohao/LOAssetFramework.git

# 使用text存储日志存在的问题
如果使用UI中的text存储日志并展示日志，存在一个巨大的问题。当text长度过长之后，unity就会报错，说渲染的数据量过大。