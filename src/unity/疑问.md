# Image和RawImage的区别
RawImage核心代码比Image少很多，Raw Image不支持交互，可用于显示任何图片而不仅仅是Sprite，一般用在背景、图标上,支持UV Rect(用来设置只显示图片的某一部分)，而Image不支持UV Rect
# unity3d打印日志
`Debug.Log("This is debug");`
# find an inactive object
Unity的对象树许多关键功能是缺失的，需要开发者自己实现。对于寻找inactive的物体这一简单功能，unity没有提供便捷的函数，使用Resources.FindObjectsTypeAll能够实现。  

```cs
 var fooGroup = Resources.FindObjectsOfTypeAll<AnUniqueClass>();
 if (fooGroup.Length > 0) {
   var foo = fooGroup[0];
 }
```

下面是[网上的一些讨论](https://answers.unity.com/questions/890636/find-an-inactive-game-object.html)：
> Oh my god, I can't believe they didn't support this simple, essential and frequent feature even in 2018...?!?!?!

> That's got to be a real wrong name choice here. I would never expect to look into that class. Resources tells me it deals with resources folder, so how come this find them in the scene??!! Is that another intern job at Unity? Anyway, it does the job indeed.
> don't use this method. it has permanent effect on your assets. find another solution.

```
SpriteRenderer[] onlyActive = GameObject.FindObjectsOfType<SpriteRenderer>();

SpriteRenderer[] activeAndInactive = GameObject.FindObjectsOfType<SpriteRenderer>(true);

// requires "using System.Linq;"
SpriteRenderer[] onlyInactive = GameObject.FindObjectsOfType<SpriteRenderer>(true).Where(sr => !sr.gameObject.activeInHierarchy).ToArray();
```

# 寻找一个对象下的某个对象
实现一个扩展方法：
```
 public static GameObject FindObject(this GameObject parent, string name)
 {
     Transform[] trs= parent.GetComponentsInChildren<Transform>(true);
     foreach(Transform t in trs){
         if(t.name == name){
              return t.gameObject;
         }
     }
     return null;
 }
```

使用时：
```
GameObject obj = parentObject.FindObject("MyObject");
```

# 寻找一个对象下的子组件
```
 Transform childTransform = gameObject.transform.GetComponentsInChildren<Transform>(true).FirstOrDefault(t => t.name == "Name Of Child Object");
```

# 找到所有的游戏对象
```plain
 public static List<GameObject> FindAllObjectsInScene()
     {
         UnityEngine.SceneManagement.Scene activeScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
 
         GameObject[] rootObjects = activeScene.GetRootGameObjects();
 
         GameObject[] allObjects = Resources.FindObjectsOfTypeAll<GameObject>();
 
         List<GameObject> objectsInScene = new List<GameObject>();
 
         for (int i = 0; i < rootObjects.Length; i++)
         {
             objectsInScene.Add(rootObjects[i]);
         }
 
         for (int i = 0; i < allObjects.Length; i++)
         {
             if (allObjects[i].transform.root)
             {
                 for (int i2 = 0; i2 < rootObjects.Length; i2++)
                 {
                     if (allObjects[i].transform.root == rootObjects[i2].transform && allObjects[i] != rootObjects[i2])
                     {
                         objectsInScene.Add(allObjects[i]);
                         break;
                     }
                 }
             }
         }
         return objectsInScene;
     }
```

# UGUI和NGUI的区别
1.UGUI界面展示是在画布下(Canvas)，而NGUI是在UIRoot下

2.UGUI继承RectTransform，RectTransform继承Transform，而Ngui直接继承Transform

3.UGUI没有图集Atlas，是直接使用图片，而Ngui需要使用图集，对图集进行管理和维护

4.UGUI有锚点，可以自动适配屏幕，NGUI没有暂未发现此功能

5.UGUI中Btn需要有sprite，button，而NGUI只需要一个UIButton方法，和一个BoxCollider。

6.NGUI基于C#编写的，会产出比较多的GC，UGUI是基于C++，性能比较好。基于canvas渲染比较好。


# unity创建object的三种方法
```
//1.第一种方法

GameObject go = new GameObject("name");  //name 为名字

//2.第二种方法

public GameObject prefab;

GameObject.Instantiate(prefab);//可以很具prefab 或者另外一个物体克隆

//3.第三种方法

//创建基本图形

GameObject.CreatePrimitive(PrimitiveType.Cube);
```

# unity使用prefab的两种方式
加载prefab有两种方式
* 方法一：设置脚本的public字段 ，然后再界面上传参。这种方式比较死板。
* 方法二：使用Resource.Load()
在代码里用Resource.Load()来加载实例化预设，前提是预设预提必须放在Assets/Resources的目录下。当然你也可以在 Assets/Resources/MyPrefabs。
```
// Use this for initialization
void Start () {
//参数一：是预设 参数二：实例化预设的坐标  参数三：实例化预设的旋转角度
GameObject instance = (GameObject)Instantiate(Resources.Load("Cubeprefab"), transform.position)
```

# 场景管理器
```
using UnityEngine.SceneManagement;

SceneManager.LoadScene("2048");
SceneManager.GetAllScenes();
SceneManager.GetSceneByName();
SceneManager.GetSceneByPath();
SceneManager.MoveGameObjectToScene();
Debug.Log(SceneManager.getscene)
```